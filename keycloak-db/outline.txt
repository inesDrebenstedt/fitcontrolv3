When using Keycloak as your Identity and Access Management (IAM) solution with a Spring Boot project, the "best practice" for "user storage" fundamentally revolves around delegating identity management to Keycloak and only storing application-specific data in your Spring Boot application's database.

Here's a breakdown of the best practices:

Core Principle: Keycloak Owns User Identity

The most crucial best practice is to understand that Keycloak is the authoritative source for user identity, authentication, and authorization. Your Spring Boot application should not store user passwords, email addresses (unless absolutely necessary for application-specific logic and it's already in Keycloak), or other core identity information that Keycloak already manages.

1. Keycloak's Role in User Storage

Keycloak itself stores users in one of several ways:

Internal Database: By default, Keycloak uses its own database (PostgreSQL, MySQL, etc.) to store user accounts, credentials, roles, groups, and custom attributes. This is its primary internal storage.
Federation: Keycloak can federate users from external sources:
LDAP/Active Directory: Connects to existing directory services.
Custom User Federation Providers: If you have an existing custom user database, you can write a Keycloak plugin to integrate it. This means Keycloak accesses your users, but your custom database is still the source of truth for their identity.
Social Identity Providers: Users can log in via Google, GitHub, Facebook, etc., and Keycloak links these external identities to internal Keycloak user profiles.

Best Practice (Keycloak Side):

Leverage Keycloak's internal features first. Use its user management, roles, groups, and custom attributes.
Use standard federation (LDAP/AD) if applicable. Don't reinvent the wheel.
Only implement custom user federation as a last resort (e.g., migrating from a legacy system where rebuilding user management in Keycloak is not feasible).
2. Spring Boot Application's Role in User Storage (Application-Specific Data)

Your Spring Boot application primarily interacts with Keycloak by receiving and validating JSON Web Tokens (JWTs). These JWTs contain claims about the authenticated user (e.g., user ID, username, email, roles).

The application should store data related to a user that is specific to the application's domain and functionality, and not core identity information.

Best Practices for Application-Specific User Storage:

Link, Don't Duplicate Identity:

When an authenticated user interacts with your application for the first time, you might create a corresponding entry in your application's database.
Crucially, use the Keycloak user's unique identifier as the primary link. The sub (subject) claim in the JWT is the most stable and recommended identifier. It's a GUID/UUID unique to the user within Keycloak. Alternatively, preferred_username can be used if it's guaranteed to be unique and stable, but sub is generally safer.
Example:
@Entity
public class AppUserProfile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String keycloakUserId; // Stores the 'sub' claim from Keycloak

    private String appSpecificPreference; // e.g., "dark_mode"
    private String avatarUrl; // User's custom avatar for this app
    private LocalDateTime lastLogin; // Last login *to this specific app*
    // ... other application-specific fields ...

    // Getters and Setters
}


Store Only Necessary Application Data:

DO store: User preferences, application-specific settings, relationships to other application entities (e.g., orders, projects, documents), a flag indicating if they completed onboarding for this app, application-specific roles/permissions (though ideally, Keycloak would manage all roles).
DO NOT store (if Keycloak already has it): Passwords, email addresses (unless it's integral to this app's unique processes and Keycloak provides it), full names (if simply for display and available via JWT). If you store email for application validation (e.g., verifying a separate app-specific email), ensure it's securely handled.
Principle of Least Privilege: Only store what your application needs to function.

Database Choice:

Use your standard relational database (PostgreSQL, MySQL, H2, etc.) or NoSQL database (MongoDB, Cassandra, etc.) that your Spring Boot application already uses for other domain entities. Spring Data JPA or Spring Data MongoDB are excellent choices.

Retrieving User Information in Spring Boot:

Spring Security, when configured as an OAuth2 Resource Server, will parse the JWT and populate the Authentication object (specifically JwtAuthenticationToken).
You can easily access claims from the JWT:
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping("/me")
    public String getUserInfo(Authentication authentication) {
        if (authentication instanceof JwtAuthenticationToken) {
            JwtAuthenticationToken jwtAuthentication = (JwtAuthenticationToken) authentication;
            Jwt jwt = jwtAuthentication.getToken();

            String userId = jwt.getSubject(); // This is the 'sub' claim from Keycloak
            String username = jwt.getClaimAsString("preferred_username"); // Or 'sub'
            String email = jwt.getClaimAsString("email");
            // List<String> roles = jwt.getClaimAsStringList("roles"); // If you mapped roles in Keycloak

            // Now you can use userId to look up app-specific data
            // AppUserProfile profile = appUserProfileRepository.findByKeycloakUserId(userId);

            return "Hello " + username + " (ID: " + userId + ", Email: " + email + ")";
        }
        return "Not authenticated as a Keycloak user.";
    }
}


Keycloak Client Configuration (Mappers):

Ensure your Keycloak client configuration includes mappers to push relevant user attributes (like email, preferred_username, custom attributes) into the JWT's claims. By default, sub is always present. To add roles, you'll need a "User Realm Role" or "User Client Role" mapper.

Caching:

If you frequently retrieve application-specific user data (e.g., AppUserProfile), consider caching it (e.g., Spring Cache, Redis) to reduce database load.
3. Spring Boot Security Configuration Example

Here's a basic setup for Spring Boot to act as an OAuth2 Resource Server, trusting Keycloak:

pom.xml dependencies:

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId> <!-- For AppUserProfile -->
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId> <!-- Example Dev DB -->
        <scope>runtime</scope>
    </dependency>
    <!-- Other dependencies like PostgreSQL driver if needed -->
</dependencies>


application.yml (or application.properties):

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          # This is the base URL of your Keycloak server's realm
          # e.g., http://localhost:8080/realms/myrealm
          issuer-uri: http://localhost:8080/realms/myrealm
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  datasource:
    url: jdbc:h2:mem:appdb
    driverClassName: org.h2.Driver
    username: sa
    password: password


SecurityConfig.java:

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity // Enable @PreAuthorize, @PostAuthorize, etc.
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // Disable CSRF for typical API
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/public/**").permitAll() // Allow public access
                .anyRequest().authenticated() // All other requests require authentication
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    // Default JWT processing is sufficient with issuer-uri
                    // You can add a custom converter here if needed for role mapping, etc.
                    // .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            )
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); // APIs are stateless

        return http.build();
    }

    // Optional: Custom converter to map Keycloak roles to Spring Security GrantedAuthorities
    // This is useful if Keycloak roles are in a custom claim or you want to prefix them.
    /*
    @Bean
    public Converter<Jwt, Collection<GrantedAuthority>> jwtGrantedAuthoritiesConverter() {
        return jwt -> {
            // Assuming Keycloak puts roles in a 'realm_access.roles' claim
            Map<String, Object> realmAccess = jwt.getClaimAsMap("realm_access");
            if (realmAccess != null && realmAccess.containsKey("roles")) {
                List<String> roles = (List<String>) realmAccess.get("roles");
                return roles.stream()
                        .map(roleName -> "ROLE_" + roleName.toUpperCase()) // Prefix with ROLE_ for Spring Security
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());
            }
            return Collections.emptyList();
        };
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();
        jwtConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter());
        // You might also set the principal claim name if it's not 'sub'
        // jwtConverter.setPrincipalClaimName("preferred_username");
        return jwtConverter;
    }
    */
}

Summary of Best Practices:
Keycloak is the SOLE Identity Provider: All authentication, password management, MFA, and core identity data reside in Keycloak.
Spring Boot Stores Application-Specific Data ONLY: Create a separate AppUserProfile (or similar) entity in your application's database.
Link via Keycloak sub: Use the sub claim from the JWT as the foreign key/unique identifier to link your application’s user data to the Keycloak user.
No Duplicate Sensitive Data: Do not store passwords, or replicate core identity data (like email) in your app's DB if Keycloak already manages it and it's not critical for a unique app function.
Retrieve User Info from JWT: Access user details (ID, username, email, roles) from the JwtAuthenticationToken provided by Spring Security.
Configure Keycloak Mappers: Ensure Keycloak sends all necessary user attributes (especially roles and desired claims) in the JWT to your Spring Boot application.
Use Spring Security OAuth2 Resource Server: Configure your Spring Boot app to validate JWTs issued by Keycloak.
Stateless Sessions: For API-driven applications, ensure SessionCreationPolicy.STATELESS as authorization is handled per request via the JWT.

By following these practices, you maintain a clean separation of concerns, enhance security, and leverage the full power of Keycloak for identity management, while keeping your application focused on its core business logic.

---------------------------

When using Keycloak as your Identity and Access Management (IAM) solution with a Spring Boot project, the "best practice" for "user storage" fundamentally revolves around delegating identity management to Keycloak and only storing application-specific data in your Spring Boot application's database.

Here's a breakdown of the best practices:

Core Principle: Keycloak Owns User Identity

The most crucial best practice is to understand that Keycloak is the authoritative source for user identity, authentication, and authorization. Your Spring Boot application should not store user passwords, email addresses (unless absolutely necessary for application-specific logic and it's already in Keycloak), or other core identity information that Keycloak already manages.

1. Keycloak's Role in User Storage

Keycloak itself stores users in one of several ways:

Internal Database: By default, Keycloak uses its own database (PostgreSQL, MySQL, etc.) to store user accounts, credentials, roles, groups, and custom attributes. This is its primary internal storage.
Federation: Keycloak can federate users from external sources:
LDAP/Active Directory: Connects to existing directory services.
Custom User Federation Providers: If you have an existing custom user database, you can write a Keycloak plugin to integrate it. This means Keycloak accesses your users, but your custom database is still the source of truth for their identity.
Social Identity Providers: Users can log in via Google, GitHub, Facebook, etc., and Keycloak links these external identities to internal Keycloak user profiles.

Best Practice (Keycloak Side):

Leverage Keycloak's internal features first. Use its user management, roles, groups, and custom attributes.
Use standard federation (LDAP/AD) if applicable. Don't reinvent the wheel.
Only implement custom user federation as a last resort (e.g., migrating from a legacy system where rebuilding user management in Keycloak is not feasible).
2. Spring Boot Application's Role in User Storage (Application-Specific Data)

Your Spring Boot application primarily interacts with Keycloak by receiving and validating JSON Web Tokens (JWTs). These JWTs contain claims about the authenticated user (e.g., user ID, username, email, roles).

The application should store data related to a user that is specific to the application's domain and functionality, and not core identity information.

Best Practices for Application-Specific User Storage:

Link, Don't Duplicate Identity:

When an authenticated user interacts with your application for the first time, you might create a corresponding entry in your application's database.
Crucially, use the Keycloak user's unique identifier as the primary link. The sub (subject) claim in the JWT is the most stable and recommended identifier. It's a GUID/UUID unique to the user within Keycloak. Alternatively, preferred_username can be used if it's guaranteed to be unique and stable, but sub is generally safer.
Example:
@Entity
public class AppUserProfile {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(unique = true, nullable = false)
    private String keycloakUserId; // Stores the 'sub' claim from Keycloak

    private String appSpecificPreference; // e.g., "dark_mode"
    private String avatarUrl; // User's custom avatar for this app
    private LocalDateTime lastLogin; // Last login *to this specific app*
    // ... other application-specific fields ...

    // Getters and Setters
}


Store Only Necessary Application Data:

DO store: User preferences, application-specific settings, relationships to other application entities (e.g., orders, projects, documents), a flag indicating if they completed onboarding for this app, application-specific roles/permissions (though ideally, Keycloak would manage all roles).
DO NOT store (if Keycloak already has it): Passwords, email addresses (unless it's integral to this app's unique processes and Keycloak provides it), full names (if simply for display and available via JWT). If you store email for application validation (e.g., verifying a separate app-specific email), ensure it's securely handled.
Principle of Least Privilege: Only store what your application needs to function.

Database Choice:

Use your standard relational database (PostgreSQL, MySQL, H2, etc.) or NoSQL database (MongoDB, Cassandra, etc.) that your Spring Boot application already uses for other domain entities. Spring Data JPA or Spring Data MongoDB are excellent choices.

Retrieving User Information in Spring Boot:

Spring Security, when configured as an OAuth2 Resource Server, will parse the JWT and populate the Authentication object (specifically JwtAuthenticationToken).
You can easily access claims from the JWT:
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.oauth2.jwt.Jwt;
import org.springframework.security.oauth2.server.resource.authentication.JwtAuthenticationToken;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class UserController {

    @GetMapping("/me")
    public String getUserInfo(Authentication authentication) {
        if (authentication instanceof JwtAuthenticationToken) {
            JwtAuthenticationToken jwtAuthentication = (JwtAuthenticationToken) authentication;
            Jwt jwt = jwtAuthentication.getToken();

            String userId = jwt.getSubject(); // This is the 'sub' claim from Keycloak
            String username = jwt.getClaimAsString("preferred_username"); // Or 'sub'
            String email = jwt.getClaimAsString("email");
            // List<String> roles = jwt.getClaimAsStringList("roles"); // If you mapped roles in Keycloak

            // Now you can use userId to look up app-specific data
            // AppUserProfile profile = appUserProfileRepository.findByKeycloakUserId(userId);

            return "Hello " + username + " (ID: " + userId + ", Email: " + email + ")";
        }
        return "Not authenticated as a Keycloak user.";
    }
}


Keycloak Client Configuration (Mappers):

Ensure your Keycloak client configuration includes mappers to push relevant user attributes (like email, preferred_username, custom attributes) into the JWT's claims. By default, sub is always present. To add roles, you'll need a "User Realm Role" or "User Client Role" mapper.

Caching:

If you frequently retrieve application-specific user data (e.g., AppUserProfile), consider caching it (e.g., Spring Cache, Redis) to reduce database load.
3. Spring Boot Security Configuration Example

Here's a basic setup for Spring Boot to act as an OAuth2 Resource Server, trusting Keycloak:

pom.xml dependencies:

<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-oauth2-resource-server</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jpa</artifactId> <!-- For AppUserProfile -->
    </dependency>
    <dependency>
        <groupId>com.h2database</groupId>
        <artifactId>h2</artifactId> <!-- Example Dev DB -->
        <scope>runtime</scope>
    </dependency>
    <!-- Other dependencies like PostgreSQL driver if needed -->
</dependencies>


application.yml (or application.properties):

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          # This is the base URL of your Keycloak server's realm
          # e.g., http://localhost:8080/realms/myrealm
          issuer-uri: http://localhost:8080/realms/myrealm
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        format_sql: true
  datasource:
    url: jdbc:h2:mem:appdb
    driverClassName: org.h2.Driver
    username: sa
    password: password


SecurityConfig.java:

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity // Enable @PreAuthorize, @PostAuthorize, etc.
public class SecurityConfig {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable()) // Disable CSRF for typical API
            .authorizeHttpRequests(authorize -> authorize
                .requestMatchers("/public/**").permitAll() // Allow public access
                .anyRequest().authenticated() // All other requests require authentication
            )
            .oauth2ResourceServer(oauth2 -> oauth2
                .jwt(jwt -> jwt
                    // Default JWT processing is sufficient with issuer-uri
                    // You can add a custom converter here if needed for role mapping, etc.
                    // .jwtAuthenticationConverter(jwtAuthenticationConverter())
                )
            )
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)); // APIs are stateless

        return http.build();
    }

    // Optional: Custom converter to map Keycloak roles to Spring Security GrantedAuthorities
    // This is useful if Keycloak roles are in a custom claim or you want to prefix them.
    /*
    @Bean
    public Converter<Jwt, Collection<GrantedAuthority>> jwtGrantedAuthoritiesConverter() {
        return jwt -> {
            // Assuming Keycloak puts roles in a 'realm_access.roles' claim
            Map<String, Object> realmAccess = jwt.getClaimAsMap("realm_access");
            if (realmAccess != null && realmAccess.containsKey("roles")) {
                List<String> roles = (List<String>) realmAccess.get("roles");
                return roles.stream()
                        .map(roleName -> "ROLE_" + roleName.toUpperCase()) // Prefix with ROLE_ for Spring Security
                        .map(SimpleGrantedAuthority::new)
                        .collect(Collectors.toList());
            }
            return Collections.emptyList();
        };
    }

    @Bean
    public JwtAuthenticationConverter jwtAuthenticationConverter() {
        JwtAuthenticationConverter jwtConverter = new JwtAuthenticationConverter();
        jwtConverter.setJwtGrantedAuthoritiesConverter(jwtGrantedAuthoritiesConverter());
        // You might also set the principal claim name if it's not 'sub'
        // jwtConverter.setPrincipalClaimName("preferred_username");
        return jwtConverter;
    }
    */
}

Summary of Best Practices:
Keycloak is the SOLE Identity Provider: All authentication, password management, MFA, and core identity data reside in Keycloak.
Spring Boot Stores Application-Specific Data ONLY: Create a separate AppUserProfile (or similar) entity in your application's database.
Link via Keycloak sub: Use the sub claim from the JWT as the foreign key/unique identifier to link your application’s user data to the Keycloak user.
No Duplicate Sensitive Data: Do not store passwords, or replicate core identity data (like email) in your app's DB if Keycloak already manages it and it's not critical for a unique app function.
Retrieve User Info from JWT: Access user details (ID, username, email, roles) from the JwtAuthenticationToken provided by Spring Security.
Configure Keycloak Mappers: Ensure Keycloak sends all necessary user attributes (especially roles and desired claims) in the JWT to your Spring Boot application.
Use Spring Security OAuth2 Resource Server: Configure your Spring Boot app to validate JWTs issued by Keycloak.
Stateless Sessions: For API-driven applications, ensure SessionCreationPolicy.STATELESS as authorization is handled per request via the JWT.

By following these practices, you maintain a clean separation of concerns, enhance security, and leverage the full power of Keycloak for identity management, while keeping your application focused on its core business logic.